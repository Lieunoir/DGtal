<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Normal corrected Finite Element Method for Poisson problems</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;1.4.beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('moduleNormalCorrectedFEM.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Normal corrected Finite Element Method for Poisson problems</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sectNormalCorrectedFEMIntro">Introduction</a></li>
<li class="level1"><a href="#sectNormalCorrectedFEMface">Per face operators</a><ul><li class="level2"><a href="#sublap">Mass matrix and stiffness matrix</a></li>
</ul>
</li>
<li class="level1"><a href="#sectPolygonalCalculusGlo">Global operators</a></li>
<li class="level1"><a href="#secLap">Example: Solving a Laplace problem</a></li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Colin Weill&ndash;Duflos</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.4</dd></dl>
<p>Part of package <a class="el" href="packageDEC.html">DEC package</a>.</p>
<p>In this documentation page, we detail a laplacian operator computations on surface mesh equipped with faces normals.</p>
<dl class="section note"><dt>Note</dt><dd>The sign convention for the divergence and the Laplacian operator is opposite to the one of <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[44]</a>. This is to match the usual mathematical convention that the Laplacian (and the Laplacian-Beltrami) has negative eigenvalues (and is the sum of second derivatives in the cartesian grid). It also follows the formal adjointness of exterior derivative and opposite of divergence as relation  \( \langle \mathrm{d} u, v \rangle = - \langle u,
\mathrm{div} v \rangle \). See also <a href="https://en.wikipedia.org/wiki/Laplace–Beltrami_operator">https://en.wikipedia.org/wiki/Laplace–Beltrami_operator</a></dd>
<dd>
All illustrations below have been obtained using the DGtal+<a href="https://polyscope.run">polyscope</a> examples <a class="el" href="dgtalCalculus_8cpp_source.html">dgtalCalculus.cpp</a>, <a class="el" href="dgtalCalculus-single_8cpp_source.html">dgtalCalculus-single.cpp</a> and <a class="el" href="dgtalCalculus-poisson_8cpp_source.html">dgtalCalculus-poisson.cpp</a>. To build these examples, enable the <code>BUILD_POLYSCOPE_EXAMPLES</code> variable (e.g. <code>cmake .. -DBUILD_POLYSCOPE_EXAMPLES=ON</code>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The implementation heavily relies on implicit operators with many Eigen based small matrice constructions, which has a huge overhead in Debug mode. Please consider to build the examples in Release (<em>e.g.</em> <code>CMAKE_BUILD_TYPE</code> variable) for high performance on large geometrical objects.</dd></dl>
<h1><a class="anchor" id="sectNormalCorrectedFEMIntro"></a>
Introduction</h1>
<p>We aim at solving a problem of the form \(\Delta u = f\). We follows the Finite Element Method to derive two matrices \(L, M\) such that \(L \mathbf{u} = M \mathbf{f}\). We use a normal based metric to make our operator work on digital surfaces.</p>
<p>The metric used is  \( G = \begin{bmatrix} 1 - (\mathbf{u}_x)^2 &amp; -\mathbf{u}_x \mathbf{u}_y \\
-\mathbf{u}_x \mathbf{u}_y &amp; 1-(\mathbf{u}_y)^2 \end{bmatrix} \)</p>
<p>Where \(\mathbf{u} = (\mathbf{u}_x, \mathbf{u}_y, \mathbf{u}_z)\) is the provided normal for a surfel in the natural coordinate surface of the surfel.</p>
<h1><a class="anchor" id="sectNormalCorrectedFEMface"></a>
Per face operators</h1>
<p>Let us consider a single square face example. Using</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>ncFEM = NormalCorrectedFEM&lt;EigenLinearAlgebraBackend, Z3i::RealPoint, Z3i::RealVector&gt;;</div>
<div class="line"><span class="keyword">using </span>SurfMesh = SurfaceMesh&lt;Z3i::RealPoint,Z3i::RealVector&gt;;</div>
<div class="line"><span class="keyword">using namespace </span>Z3i;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Vertices</span></div>
<div class="line">std::vector&lt;RealPoint&gt; positions={ {0,0,0},{1,0,0},{1,1,0},{0,0,1} };</div>
<div class="line"><span class="comment">//Single face</span></div>
<div class="line">std::vector&lt;std::vector&lt;size_t&gt;&gt; faces={{ 0,1,2,3 }};</div>
<div class="line"> </div>
<div class="line">mesh = SurfMesh(positions.begin(),positions.end(),faces.begin(),faces.end());</div>
<div class="line"><span class="comment">// We require normal at faces. For digital surfaces, prefer using a convergent estimator</span></div>
<div class="line">mesh.computeFaceNormalsFromPositions();</div>
<div class="line"> </div>
<div class="line">ncFEM calculus(mesh);</div>
</div><!-- fragment --><p>we obtain a <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> instance with a unique face, we add the naturally defined normal to it and we define its associated <a class="el" href="structDGtal_1_1NormalCorrectedFEM.html" title="Aim: Provides methods for building a stiffness and mass matrix to solve Poisson problems using the Fi...">NormalCorrectedFEM</a> object.</p>
<p>Let us add a scalar function on vertices. For instance, using Eigen syntax, we can use;</p>
<div class="fragment"><div class="line">ncFEM::DenseVector phi(4); <span class="comment">//5 vertices</span></div>
<div class="line">phi &lt;&lt; 1.0, 2.0, 0.0, 5.0;</div>
</div><!-- fragment --><h2><a class="anchor" id="sublap"></a>
Mass matrix and stiffness matrix</h2>
<p>The expression for the integral of the product of two functions \(f\) and \(g\) inside a surfel is given by the following expression : </p><p class="formulaDsp">
\[ \int_{\square} \sqrt{det(G)}fg \]
</p>
<p>The expression for the integral of the dot product of the gradient of two functions \(f\) and \(g\) inside a surfel is given by the following expression : </p><p class="formulaDsp">
\[ \int_{\square} \sqrt{det(G)} \nabla f^T G^{-1} \nabla g \rangle \]
</p>
<p>By evaluating this expression with a linear basis, we can build matrices letting us evaluate these integrals for any two linear functions inside a face. The results can be obtained in the following way :</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operator   </th><th class="markdownTableHeadNone">Output   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>calculus.localM0(f)</code>   </td><td class="markdownTableBodyNone">\( n_v\times n_v\)   </td><td class="markdownTableBodyNone">mass matrix (corresponds to the inner product between 0 forms in <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[44]</a>)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>calculus.localL0(f)</code>   </td><td class="markdownTableBodyNone">\( n_v \times n_v\)   </td><td class="markdownTableBodyNone">stiffness matrix (corresponds to Laplace-Beltrami operator in <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[44]</a>), the matrix is PSD   </td></tr>
</table>
<h1><a class="anchor" id="sectPolygonalCalculusGlo"></a>
Global operators</h1>
<p>Given a scalar function defined on a generic surface mesh vertices, all previously mentioned operators can be applied to obtain consistent quantities on the overall mesh.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operator   </th><th class="markdownTableHeadNone">Output   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>calculus.M0()</code>   </td><td class="markdownTableBodyNone">\( n_v \times n_v\)   </td><td class="markdownTableBodyNone">global mass matrix (PD)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>calculus.lumpedM0()</code>   </td><td class="markdownTableBodyNone">\( n_v \times n_v\)   </td><td class="markdownTableBodyNone">global lumped mass matrix (Diagonal, positive)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>calculus.L0()</code>   </td><td class="markdownTableBodyNone">\( n_v \times n_v\)   </td><td class="markdownTableBodyNone">global stiffness matrix (SPD)   </td></tr>
</table>
<h1><a class="anchor" id="secLap"></a>
Example: Solving a Laplace problem</h1>
<p>Let suppose we want to solve the following Laplace problem for data interpolation:    </p><p class="formulaDsp">
\begin{eqnarray*}
        \Delta_\Omega u&amp; = 0  \\
        &amp; s.t. u = g \text{ on } \partial\Omega
\end{eqnarray*}
</p>
<p>We want to solve that problem on a digital surface \(\Omega\) with a boundary and some scalar values attached to boundary vertices, or sampled on the object surface.</p>
<p>Furthermore, the discrete version of the Laplace problem boils down to a simple linear problem using on the discrete Laplace-Beltrami sparse matrix.</p>
<p>We also use class <a class="el" href="classDGtal_1_1DirichletConditions.html" title="Aim: A helper class to solve a system with Dirichlet boundary conditions.">DirichletConditions</a> to enforce Dirichlet boundary conditions on the system.</p>
<p>The overall code is: </p><div class="fragment"><div class="line">  <span class="keyword">typedef</span> <a class="code hl_struct" href="structDGtal_1_1NormalCorrectedFEM.html">NormalCorrectedFEM&lt;EigenLinearAlgebraBackend, SH3::RealPoint,SH3::RealVector&gt;</a> ncFEM;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1DirichletConditions.html">DirichletConditions&lt; EigenLinearAlgebraBackend &gt;</a>  DC;</div>
<div class="line">  ncFEM calculus(surfmesh);</div>
<div class="line">  ncFEM::LinearOperator L = calculus.L0();</div>
<div class="line">  ncFEM::DenseVector g = ncFEM::DenseVector::Zero(surfmesh.nbVertices());</div>
<div class="line">  DC::IntegerVector b = DC::IntegerVector::Zero( g.rows() );</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//We set values on the boundary</span></div>
<div class="line">  <span class="keyword">auto</span> boundaryEdges = surfmesh.computeManifoldBoundaryEdges();</div>
<div class="line">  std::cout&lt;&lt; <span class="stringliteral">&quot;Number of boundary edges= &quot;</span>&lt;&lt;boundaryEdges.size()&lt;&lt;std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> pihVertex=[&amp;](<span class="keyword">const</span> <a class="code hl_typedef" href="structDGtal_1_1SurfaceMesh.html#ac8fba76a794fd9912af755f620606cf0">SurfMesh::Vertex</a> &amp;v){<span class="keywordflow">return</span>  cos(scale*(surfmesh.position(v)[0]))*(scale*surfmesh.position(v)[1]);};</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;e: boundaryEdges)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">auto</span> adjVertices = surfmesh.edgeVertices(e);</div>
<div class="line">    g(adjVertices.first)  = pihVertex(adjVertices.first);</div>
<div class="line">    g(adjVertices.second) = pihVertex(adjVertices.second);</div>
<div class="line">    b(adjVertices.first)  = 1;</div>
<div class="line">    b(adjVertices.second) = 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Solve Δu=0 with g as boundary conditions</span></div>
<div class="line">  ncFEM::LinearAlgebraBackend::SolverSimplicialLDLT solver;</div>
<div class="line">  ncFEM::LinearOperator L_dirichlet = DC::dirichletOperator( L, b );</div>
<div class="line">  solver.compute( L_dirichlet );</div>
<div class="line">  ASSERT(solver.info()==Eigen::Success);</div>
<div class="line">  ncFEM::DenseVector g_dirichlet = DC::dirichletVector( L, g, b, g );</div>
<div class="line">  ncFEM::DenseVector x_dirichlet = solver.solve( g_dirichlet );</div>
<div class="line">  ncFEM::DenseVector u = DC::dirichletSolution( x_dirichlet, b, g );</div>
</div><!-- fragment --><p>Leading to the following results (see <a class="el" href="dgtalFEM-poisson_8cpp_source.html">dgtalFEM-poisson.cpp</a>):</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Surface   </th><th class="markdownTableHeadNone">Boundary condition \( g\)   </th><th class="markdownTableHeadNone">Solution \( u \)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><div class="image">
<img src="poisson-fem-surf.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="poisson-fem-g.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="poisson-fem-u.png" alt=""/>
</div>
   </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">DGtal - Digital Geometry Tools and Algorithms Library.</a></li><li class="navelem"><a class="el" href="packageDEC.html">DEC package</a></li>
    <li class="footer">Generated on Wed Jun 5 2024 18:11:14 for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
